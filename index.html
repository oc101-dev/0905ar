<!-- マーカーを読み込んで３Ｄモデルを表示 + アニメーション再生(anime01 → anime02 → anime03 → anime04)  -->

<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- A-Frame を読み込む -->
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <!-- AR.js を読み込む -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <!-- Gesture Handler を読み込む -->
    <script src="https://raw.githack.com/AR-js-org/studio-backend/master/src/modules/marker/tools/gesture-handler.js"></script>
    <!-- Animation Mixer を読み込む -->
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
    <script>
      // モデルの状態を管理するコンポーネント
      AFRAME.registerComponent('model-controller', {
        schema: {
          // 初期位置
          initialPosition: { type: 'vec3', default: { x: 0, y: 0, z: 0 } },
          // 移動後の位置
          moveToPosition: { type: 'vec3', default: { x: 3, y: 0, z: 0 } }
        },

        init: function () {
          // モデルの初期状態を設定
          this.el.setAttribute('position', this.data.initialPosition);
          
          // アニメーション状態を初期化
          this.isAnimating = false;
          this.currentState = 'initial'; // 'initial' or 'moved'

          // モデルが読み込まれた時の処理
          this.el.addEventListener('model-loaded', () => {
            // 初期アニメーション（anime01のループ）を開始
            this.playAnimation('anime01', true);
          });
        },

        // アニメーション再生関数
        playAnimation: function (clipName, loop = false) {
          if (this.isAnimating) return;
          
          this.el.setAttribute('animation-mixer', {
            clip: clipName,
            loop: loop ? 'repeat' : 'once',
            clampWhenFinished: !loop,
            timeScale: 1
          });

          // ループしないアニメーションの場合、完了イベントを監視
          if (!loop) {
            const mixer = this.el.components['animation-mixer'].mixer;
            if (mixer) {
              this.isAnimating = true;
              const onFinished = () => {
                mixer.removeEventListener('finished', onFinished);
                this.isAnimating = false;
                // アニメーション完了後の処理をここで行う
                this.onAnimationComplete(clipName);
              };
              mixer.addEventListener('finished', onFinished);
            }
          }
        },

        // アニメーション完了時の処理
        onAnimationComplete: function (completedClip) {
          if (completedClip === 'anime02') {
            // anime02完了後、anime03をループ再生しながら移動
            this.playAnimation('anime03', true);
            this.moveModel();
          }
        },

        // モデルを新しい位置に移動
        moveModel: function () {
          this.el.setAttribute('animation__position', {
            property: 'position',
            to: this.data.moveToPosition,
            dur: 1000, // 1秒かけて移動
            easing: 'easeInOutQuad'
          });

          // 移動完了後の処理
          this.el.addEventListener('animationcomplete__position', () => {
            if (this.currentState === 'initial') {
              this.currentState = 'moved';
              // 移動完了後、anime01のループ再生に戻る
              this.playAnimation('anime01', true);
            }
          }, { once: true });
        }
      });

      // クリック検知用の当たり判定コンポーネント
      AFRAME.registerComponent('clickable', {
        init: function () {
          // クリックイベントのリスナーを設定
          this.el.addEventListener('click', () => {
            // 親要素（モデル本体）のコントローラーを取得
            const modelController = this.el.parentNode.components['model-controller'];
            if (modelController && modelController.currentState === 'initial') {
              // anime02を1回再生（その後の処理はmodel-controllerで制御）
              modelController.playAnimation('anime02', false);
            }
          });
        }
      });
    </script>
    <title>***６６６***</title>
  </head>
  <body style="margin: 0; overflow: hidden">
	  
    <!-- A-FrameにAR.jsを紐づけ、VRボタン非表示、深度バッファ追加 -->
    <a-scene embedded arjs vr-mode-ui="enabled: false;" 
      renderer="logarithmicDepthBuffer: true; colorManagement: true; physicallyCorrectLights: true; exposure: 1.2;">
	    
      <!-- 3DCGモデルを読み込む -->
      <a-assets>
        <a-asset-item id="neko" src="./asset/3Dmodel.glb"></a-asset-item>
      </a-assets>

      <!-- ライティング設定 -->
      <a-entity light="type: ambient; intensity: 1.5; color: #ffffff"></a-entity>
      <a-entity light="type: directional; intensity: 1.2; color: #ffffff" position="-1 1 0.5"></a-entity>
      <a-entity light="type: hemisphere; intensity: 0.8; color: #ffffff; groundColor: #888888"></a-entity>

      <!-- マーカーの.pattファイルを読み込む -->
      <a-marker type="pattern" url="./asset/pattern-marker.patt">
        <!-- モデルのコンテナ（アニメーションと移動の制御用） -->
        <a-entity
          id="model-container"
          model-controller
          gesture-handler="minScale: 0.25; maxScale: 10"
          animation-mixer>
          
          <!-- 3Dモデル本体 -->
          <a-entity
            gltf-model="#neko"
            scale="1.5 1.5 1.5"
            rotation="0 0 0">
          </a-entity>

          <!-- クリック判定用の透明なボックス（当たり判定） -->
          <a-box
            clickable
            scale="1.5 1.5 1.5"
            position="0 1 0"
            material="opacity: 0.3"
            class="clickable">
          </a-box>
        </a-entity>
      </a-marker>

      <!-- カメラを追加 -->
      <a-entity camera></a-entity>
    </a-scene>
  </body>
</html>